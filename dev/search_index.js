var documenterSearchIndex = {"docs":
[{"location":"#TRGBDistances","page":"Home","title":"TRGBDistances","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TRGBDistances.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#TRGBDistances.BrokenPowerLaw","page":"Home","title":"TRGBDistances.BrokenPowerLaw","text":"BrokenPowerLaw(m_trgb, a, b, c) <: LuminosityFunction\n\nStandard broken power-law luminosity function typically used to model the luminosity function of the TRGB. For a magnitude m, the luminosity function is exp10(a * (m - m_trgb) + b) for m >= m_trgb and exp10(c * (m - m_trgb)) for m < m_trgb. Therefore a is the power-law slope of the RGB, b is the RGB bump, and c is the power-law slope of the AGB region.\n\nFor initial optimization conditions, eyeballing an approximate m_trgb on the CMD is usually sufficient. a = 0.3, b = 0.2, and c = 0.1 may be used as first guesses, but should be revised to match your data more closely.\n\n\n\n\n\n","category":"type"},{"location":"#TRGBDistances.LuminosityFunction","page":"Home","title":"TRGBDistances.LuminosityFunction","text":"LuminosityFunction{T} is the abstract supertype for luminosity functions that can be used to model the TRGB. Subtypes should implement ψ.\n\n\n\n\n\n","category":"type"},{"location":"#TRGBDistances.LuminosityFunctionData","page":"Home","title":"TRGBDistances.LuminosityFunctionData","text":"LuminosityFunctionData(model, mags,\n                       err_func, complete_func, bias_func)\n\nStructure to hold data for optimizing the given model. mags should typically be an array of apparent magnitudes with reddening correction applied. err_func(m) must return the photometric error at magnitude m, while complete_func(m) and bias_func(m) return the photometric completeness and bias (defined as <measured> - <input>), respectively.\n\nWhen called with a vector of parameters θ, returns the negative logarithm of the likelihood (Equation 7 in Makarov+2006). This enables convenient optimization calls as most optimization routines will minimize an objective. For example, to optimize with the Nelder-Mead algorithm of Optim.jl, call result = Optim.optimize(LuminosityFunctionData(...), x0, Optim.NelderMead()). The maximum likelihood values are then Optim.minimizer(result).\n\n\n\n\n\n","category":"type"},{"location":"#TRGBDistances.Fusco2012-Tuple{Any}","page":"Home","title":"TRGBDistances.Fusco2012","text":"Fusco2012(color)\n\nReturns M_{F814W} given a F475W - F814W color.\n\n\n\n\n\n","category":"method"},{"location":"#TRGBDistances.Rizzi2007-Tuple{Any, Symbol, Symbol, Symbol}","page":"Home","title":"TRGBDistances.Rizzi2007","text":"Rizzi2007(color, obssym::Symbol, magsym::Symbol, colorsym::Symbol)\n\nColor-dependent TRGB zeropoint magnitude from Rizzi+2007. \n\njulia> TRGBDistances.Rizzi2007(1.5, :ACS, :F814W, :F606W) ≈ -4.006\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#TRGBDistances.filter_mags-NTuple{5, Any}","page":"Home","title":"TRGBDistances.filter_mags","text":"filter_mags(colors, mags, ridge_colors, ridge_mags, func)\n\nReturns indices into colors and mags of stars that fall within range of a ridgeline defined by ridge_colors and ridge_mags. The selection region is defined by the callable func(m) for magnitude m which must return a width. A star is accepted if its color falls between ± func(m) of the ridgeline. \n\n\n\n\n\n","category":"method"},{"location":"#TRGBDistances.ψ","page":"Home","title":"TRGBDistances.ψ","text":"ψ(model::LuminosityFunction, m)\n\nReturns the luminosity function of the model at magnitude m.\n\n\n\n\n\n","category":"function"}]
}
